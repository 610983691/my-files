#String


 本质来说，String是一个char的数组。可以根据定义看出来：
    
	private final char value[];//数组

	 public String() {
        this.value = new char[0];
    }


#Writer
之前自己关于流的读写，很多时候还要参考一些网上的资料。我觉得不能得过且过，虽说不一定把源码通读一遍，细致入微，但至少要对IO的基本操作原理这些有一定了解。需要知道一些在底层处理的方式。

##字符流
从本质上来说，writer是一个字符流。
查看源码JDK7的类声明：
    
	public abstract class Writer implements Appendable, Closeable, Flushable 

源码中主要的字段和方法：
    
	 /**
     * Temporary buffer used to hold writes of strings and single characters
     */
    private char[] writeBuffer;

    /**
     * Size of writeBuffer, must be >= 1
     */
    private final int writeBufferSize = 1024;

锁的定义，说明Writer是线程安全的。

	/**
     * The object used to synchronize operations on this stream.  For
     * efficiency, a character-stream object may use an object other than
     * itself to protect critical sections.  A subclass should therefore use
     * the object in this field rather than <tt>this</tt> or a synchronized
     * method.
     */
    protected Object lock;


最重要的写方法：

	public void write(int c) throws IOException {//往流中写1个字符，写的值是c对应的的char值
        synchronized (lock) {
            if (writeBuffer == null){
                writeBuffer = new char[writeBufferSize];
            }
            writeBuffer[0] = (char) c;
            write(writeBuffer, 0, 1);
        }
    }

	//往流中写入一个字符数组
	public void write(char cbuf[]) throws IOException {
        write(cbuf, 0, cbuf.length);
    }

	//抽象方法，子类需要实现的，将cbuf的off开始的len个长度的字符写到流中
	abstract public void write(char cbuf[], int off, int len) throws IOException;

	//往流里边写入一个字符串
	public void write(String str) throws IOException {
        write(str, 0, str.length());
    }
	
	//将字符串从指定的off位置开始，往流中写入len长度个字符
	public void write(String str, int off, int len) throws IOException {
        synchronized (lock) {
            char cbuf[];
            if (len <= writeBufferSize) {//默认的buffer是1024个字符
                if (writeBuffer == null) {
                    writeBuffer = new char[writeBufferSize];
                }
                cbuf = writeBuffer;
            } else {    // Don't permanently allocate very large buffers.
                cbuf = new char[len];//我想这就是为啥建议子类尽量重写，因为这里的buffer长度是根据len来指定的，如果len很长，那么这个效率肯定就不高
            }
            str.getChars(off, (off + len), cbuf, 0);//把字符串中指定位置的字符复制到cbuf数组的从0开始的下标后面
            write(cbuf, 0, len);
        }
    }

	//往流里边追加字符序列
	public Writer append(CharSequence csq) throws IOException {
        if (csq == null)//需要注意的是，如果是一个null，那么流里边会被写入一个null字符串
            write("null");
        else
            write(csq.toString());
        return this;
    }

两个常用的未实现的抽象方法：

	/**
     * Flushes the stream.  If the stream has saved any characters from the
     * various write() methods in a buffer, write them immediately to their
     * intended destination.  Then, if that destination is another character or
     * byte stream, flush it.  Thus one flush() invocation will flush all the
     * buffers in a chain of Writers and OutputStreams.
     *
     * <p> If the intended destination of this stream is an abstraction provided
     * by the underlying operating system, for example a file, then flushing the
     * stream guarantees only that bytes previously written to the stream are
     * passed to the operating system for writing; it does not guarantee that
     * they are actually written to a physical device such as a disk drive.
     *
     * @throws  IOException
     *          If an I/O error occurs
     */
    abstract public void flush() throws IOException;

    /**
     * Closes the stream, flushing it first. Once the stream has been closed,
     * further write() or flush() invocations will cause an IOException to be
     * thrown. Closing a previously closed stream has no effect.
     *
     * @throws  IOException
     *          If an I/O error occurs
     */
    abstract public void close() throws IOException;//关闭前请先flush

#Reader
##字符流





	
	 