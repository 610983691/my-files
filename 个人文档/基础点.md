##数据结构
线性表、链表、队列、hash表、树、二叉树、二叉平衡树、图、有向图、

基本的查找排序算法：
#####1.冒泡
每次将两个相邻位置元素比较，较大的放到数组尾部。
每一轮外层循环都会冒泡出一个当前轮循环最大的元素到数组尾部。
#####2.选择排序
每一轮会将一个最大的元素放到数组尾部。
每一轮的内循环会先挨个元素比较，找到当前最大的元素的值，然后放到尾部。
#####3.直接插入排序
每次从无序表中取出第一个元素，把它插入到有序表的合适位置，使有序表仍然有序。
第一趟比较前两个数，然后把第二个数按大小插入到有序表中； 第二趟把第三个数据与前两个数从前向后扫描，把第三个数按大小插入到有序表中；
依次进行下去，进行了(n-1)趟扫描以后就完成了整个排序过程。
因为每次是插入交换位置需要一个临时变量记录元素a[i]，将数组中a[i]位置前的元素逐个往后复制，以便腾出一个位置给a[i]插入到有序表中。
#####4.快速排序
1.核心在于分割数组为left[],right[]

#####5.一般要排序的话，直接使用Collentions.sort(List<T> t,Comparator<T> t);自己实现一个comparator接口。

##集合相关
#####ArrayList
是一个线性列表，不是线程安全的，对数组的封装实现。
内部继承基本的abstractList。
特点：
> 获取指定位置的元素比较快，因为可以直接根据下标来拿。
> 
> 插入/删除元素到指定位置较慢（也跟插入是否在最后有关），因为需要对数组做一次arraycopy.（这个就跟数组容量有关了，如果容量不够还需要进行扩容操作，每次扩容默认是扩大为当前大小的1.5倍）
> 
> 想要排序可以通过collections.sort()来排序
> 
> 想要获取同步的list可以通过collections.synchronizedList来实现。
> 
> Collections.synchronized*中维护的内部类对构造函数中传入的List进行了包装，重新包装了List的add/remove等方法，方法内部使用为synchronized锁住一个Collenctions的对象来保证同步。


#####LinkedList
List 接口的链接列表实现.它还实现了Dqueue接口，即实现了双端队列，那基本的队列也实现了。然后又有push/pop方法，所以也可以把LinkedList作为一个堆栈来使用。
特点：
> 内部是维护了一个Node节点的内部类，用于表示放入LinkedList中的每个元素。注意：这个里边没有维护内部数组。
> 内部也是维护了迭代器的
> 插入/删除元素到指定的位置（最后，直接new就行），如果插入到指定的位置(我感觉不应该把链表这样去使用)，链表内部也会做for循环，一直循环到指定的index位置，然后拿到index这个节点元素，重新把index节点的前后连接关系进行修改。
> 查找指定位置的元素，需要走for循环，这个会比ArryaList慢些。

#####Vector
vector也是随机访问的线性表，和arrayList的不同在于，它是同步的。开销会比较高。

#####Stack
Stack继承了Vector,它也是线程安全的。官方不推荐使用，因为开销高？
推荐使用实现了双端队列的LinkedList。


#####Map
HashMap内部维护的是一个hash表，同时内部维护Entry(k-v)类。hash表中存的就是entry实例。
hash表的默认长度是16.
hash表扩容默认也是扩大为2倍，所以hash表的长度为2的n次方。这个是为了在计算索引值时，对2的n次方取位运算，保证其值总在table的长度范围内。
特点：
> 负载因子loadFactor,size,capacity,threshold
> threshold = loadFactor * capacity;
> size： hash表中实际存储的entry实例的个数，
> capacity： hash表的长度，即table数组的长度。
> loadFactor：一般是创建hash表的时候指定。
> 因此，增大loadFator可以减少扩容的次数，但是这样无可避免的会在hash表的某个位置“冗余”一个stack。这样会影响查询的效率。减小loadFactor时，查询会快，但是这样会有更多的扩容来增加table数组的长度来满足存储元素的要求，数据长度会直接影响内存，同时，扩容本身耗时，因为会涉及到一次数组拷贝。

说说hashCode,equals对hashmap的影响。
Java默认的hashCode方法返回的hashCode对两个实例对象来说，都是不同的，因为它们对应的是虚拟机中内存的地址。
当只覆盖equals方法时，两个对象实例可能逻辑上是equals的。但是这个时候，它们的hashCode不同，这样就会导致在put到hash表的时候，有可能放到hash表的table数组的不同下标处，也可能放到同一下标，但是是以stack的形式放到这个节点处，形成一个stack结构。

只有同时覆盖了hashCode和equals方法，才会保证hash表中，只会存一个逻辑上相等的对象。因此，当两个hashcode相等的对象，先后放入hashmap时，旧的值会被覆盖并返回，新的值将被存储。

#####TreeMap
基于红黑树(特殊的二叉排序树)的实现，不接受null值。并且不同步。要求Key必须实现comparator接口
里边维护的是一个root的根节点，因为其内部是一个树结构。

#####HashTable
与hashMap不同的就是，这个Hashtable不接受null的key和value。同时，它是线程安全的。
因为其put，get等方法是synchronized关键字修饰的。

#####LinkedHashMap
内部维护的队列可以实现根据insert的顺序来实现对map的访问。

#####HashSet
此类实现 Set 接口，由哈希表（实际上是一个 HashMap 实例）支持。它不保证 set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用 null 元素。

#####TreeSet
public class TreeSet<E> extends AbstractSet<E>
    implements NavigableSet<E>, Cloneable, java.io.Serializable
同样，这个类也是基于TreeMap来实现的，---这里也跟TreeMap一样，TreeSet的元素类型必须实现Compareable接口

#####ConcurrencyHashMap
背景：hashMap本身不是线程安全的，而使用hashtable来解决同步问题时，会遇到瓶颈。这是因为hashtable的每个方法都是synchronized修饰，这会导致不同的访问操作也会竞争锁，导致开销高，效率低。
特点：内部使用分段锁的方式，使用了可重入锁的形式。--后续可以看看资料和源码。
segment是个啥？

#####ConcurrentLinkedDeque
非阻塞的线程安全列表

#####LinkedBlockingQueue
由于LinkedBlockingQueue实现是线程安全的，实现了先进先出等特性，是作为生产者消费者的首选，LinkedBlockingQueue 可以指定容量，也可以不指定，不指定的话，默认最大是Integer.MAX_VALUE，其中主要用到put和take方法，put方法在队列满的时候会阻塞直到有队列成员被消费，take方法在队列空的时候会阻塞，直到有队列成员被放进来。

#####ConcurrentLinkedQueue
ConcurrentLinkedQueue是Queue的一个安全实现．Queue中元素按FIFO原则进行排序．采用CAS操作，来保证元素的一致性。
LinkedBlockingQueue是一个线程安全的阻塞队列，它实现了BlockingQueue接口，BlockingQueue接口继承自java.util.Queue接口，并在这个接口的基础上增加了take和put方法，这两个方法正是队列操作的阻塞版本。


#####String等基础类
##多线程、并发、同步等
#####线程池
背景介绍：
合理利用线程池能够带来三个好处。第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。
线程池参数介绍：
>corePoolSize(线程池基本大小)：线程池中活跃线程数量，需要说明的是，线程池创建的时候，线程并不会被创建(除非调用prestartCoreThread方法来初始化线程)，而是在有任务进来的时候进行创建。
>
>runnableTaskQueue(任务队列)：当线程池中执行任务的线程数量已经达到corePoolSize时，新进来的任务会被放入阻塞队列
>
>maximumPoolSize(线程池最大大小)：当阻塞队列已经满了的时候，还有任务进来，就会再创建线程，直到最大线程数量达到maximumPoolSize大小。
>
>ThreadFactory(定义线程名称)：
>RejectedExecutionHandler(饱和策略)：当池中线程的数量达到maximumPoolSize值，并且阻塞队列也满了，那么就会根据饱和策略来处理后续的任务。比如是阻塞、丢弃、抛异常、等，具体有4种饱和策略。
>
>keepAliveTime(线程活动保持时间):当线程执行完任务之后，一直空闲超过指定时间时，就会将线程回收，直到池中线程的数量达到corePoolSize大小。
>
>TimeUnit(线程活动的时间单位):

一般使用Executors类来创建线程池，而不是自己去new ThreadPoolExecutor();

常用newCachedThreadPool(缓存，超过60s回收)和newFixedThreadPool(固定容量)


#####IO、SOCKET、BUFFER
#####类加载
#####JVM内存分区、内存优化、常见参数



##数据库
####基础

####调优

####数据结构、索引


##框架
#####Spring
#####IOC/AOP


##设计模式
###单例、工厂、代理、包装器

###Linux脚本、容器配置等