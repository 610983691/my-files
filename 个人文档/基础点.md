##数据结构
线性表、链表、队列、hash表、树、二叉树、二叉平衡树、图、有向图、

基本的查找排序算法：
#####1.冒泡
每次将两个相邻位置元素比较，较大的放到数组尾部。
每一轮外层循环都会冒泡出一个当前轮循环最大的元素到数组尾部。
#####2.选择排序
每一轮会将一个最大的元素放到数组尾部。
每一轮的内循环会先挨个元素比较，找到当前最大的元素的值，然后放到尾部。
#####3.直接插入排序
每次从无序表中取出第一个元素，把它插入到有序表的合适位置，使有序表仍然有序。
第一趟比较前两个数，然后把第二个数按大小插入到有序表中； 第二趟把第三个数据与前两个数从前向后扫描，把第三个数按大小插入到有序表中；
依次进行下去，进行了(n-1)趟扫描以后就完成了整个排序过程。
因为每次是插入交换位置需要一个临时变量记录元素a[i]，将数组中a[i]位置前的元素逐个往后复制，以便腾出一个位置给a[i]插入到有序表中。
#####4.快速排序
1.核心在于分割数组为left[],right[]

#####5.一般要排序的话，直接使用Collentions.sort(List<T> t,Comparator<T> t);自己实现一个comparator接口。

##集合相关
#####ArrayList
是一个线性列表，不是线程安全的，对数组的封装实现。
内部继承基本的abstractList。
特点：
> 获取指定位置的元素比较快，因为可以直接根据下标来拿。
> 
> 插入/删除元素到指定位置较慢（也跟插入是否在最后有关），因为需要对数组做一次arraycopy.（这个就跟数组容量有关了，如果容量不够还需要进行扩容操作，每次扩容默认是扩大为当前大小的1.5倍）
> 
> 想要排序可以通过collections.sort()来排序
> 
> 想要获取同步的list可以通过collections.synchronizedList来实现。
> 
> Collections.synchronized*中维护的内部类对构造函数中传入的List进行了包装，重新包装了List的add/remove等方法，方法内部使用为synchronized锁住一个Collenctions的对象来保证同步。


#####LinkedList
List 接口的链接列表实现.它还实现了Dqueue接口，即实现了双端队列，那基本的队列也实现了。然后又有push/pop方法，所以也可以把LinkedList作为一个堆栈来使用。
特点：
> 内部是维护了一个Node节点的内部类，用于表示放入LinkedList中的每个元素。注意：这个里边没有维护内部数组。
> 内部也是维护了迭代器的
> 插入/删除元素到指定的位置（最后，直接new就行），如果插入到指定的位置(我感觉不应该把链表这样去使用)，链表内部也会做for循环，一直循环到指定的index位置，然后拿到index这个节点元素，重新把index节点的前后连接关系进行修改。
> 查找指定位置的元素，需要走for循环，这个会比ArryaList慢些。

#####Vector
vector也是随机访问的线性表，和arrayList的不同在于，它是同步的。开销会比较高。

#####Stack
Stack继承了Vector,它也是线程安全的。官方不推荐使用，因为开销高？
推荐使用实现了双端队列的LinkedList。


#####Map
HashMap内部维护的是一个hash表，同时内部维护Entry(k-v)类。hash表中存的就是entry实例。
hash表的默认长度是16.
hash表扩容默认也是扩大为2倍，所以hash表的长度为2的n次方。这个是为了在计算索引值时，对2的n次方取位运算，保证其值总在table的长度范围内。
特点：
> 负载因子loadFactor,size,capacity,threshold
> threshold = loadFactor * capacity;
> size： hash表中实际存储的entry实例的个数，
> capacity： hash表的长度，即table数组的长度。
> loadFactor：一般是创建hash表的时候指定。
> 因此，增大loadFator可以减少扩容的次数，但是这样无可避免的会在hash表的某个位置“冗余”一个stack。这样会影响查询的效率。减小loadFactor时，查询会快，但是这样会有更多的扩容来增加table数组的长度来满足存储元素的要求，数据长度会直接影响内存，同时，扩容本身耗时，因为会涉及到一次数组拷贝。

说说hashCode,equals对hashmap的影响。
Java默认的hashCode方法返回的hashCode对两个实例对象来说，都是不同的，因为它们对应的是虚拟机中内存的地址。
当只覆盖equals方法时，两个对象实例可能逻辑上是equals的。但是这个时候，它们的hashCode不同，这样就会导致在put到hash表的时候，有可能放到hash表的table数组的不同下标处，也可能放到同一下标，但是是以stack的形式放到这个节点处，形成一个stack结构。

只有同时覆盖了hashCode和equals方法，才会保证hash表中，只会存一个逻辑上相等的对象。因此，当两个hashcode相等的对象，先后放入hashmap时，旧的值会被覆盖并返回，新的值将被存储。

#####TreeMap
基于红黑树(特殊的二叉排序树)的实现，不接受null值。并且不同步。要求Key必须实现comparator接口
里边维护的是一个root的根节点，因为其内部是一个树结构。

#####HashTable
与hashMap不同的就是，这个Hashtable不接受null的key和value。同时，它是线程安全的。
因为其put，get等方法是synchronized关键字修饰的。

#####LinkedHashMap
内部维护的队列可以实现根据insert的顺序来实现对map的访问。

#####HashSet
此类实现 Set 接口，由哈希表（实际上是一个 HashMap 实例）支持。它不保证 set 的迭代顺序；特别是它不保证该顺序恒久不变。此类允许使用 null 元素。

#####TreeSet
public class TreeSet<E> extends AbstractSet<E>
    implements NavigableSet<E>, Cloneable, java.io.Serializable
同样，这个类也是基于TreeMap来实现的，---这里也跟TreeMap一样，TreeSet的元素类型必须实现Compareable接口

#####ConcurrencyHashMap
背景：hashMap本身不是线程安全的，而使用hashtable来解决同步问题时，会遇到瓶颈。这是因为hashtable的每个方法都是synchronized修饰，这会导致不同的访问操作也会竞争锁，导致开销高，效率低。
特点：内部使用分段锁的方式，使用了可重入锁的形式。--后续可以看看资料和源码。
segment是个啥？

#####ConcurrentLinkedDeque
非阻塞的线程安全列表

#####LinkedBlockingQueue
由于LinkedBlockingQueue实现是线程安全的，实现了先进先出等特性，是作为生产者消费者的首选，LinkedBlockingQueue 可以指定容量，也可以不指定，不指定的话，默认最大是Integer.MAX_VALUE，其中主要用到put和take方法，put方法在队列满的时候会阻塞直到有队列成员被消费，take方法在队列空的时候会阻塞，直到有队列成员被放进来。

#####ConcurrentLinkedQueue
ConcurrentLinkedQueue是Queue的一个安全实现．Queue中元素按FIFO原则进行排序．采用CAS操作，来保证元素的一致性。
LinkedBlockingQueue是一个线程安全的阻塞队列，它实现了BlockingQueue接口，BlockingQueue接口继承自java.util.Queue接口，并在这个接口的基础上增加了take和put方法，这两个方法正是队列操作的阻塞版本。


#####String等基础类
##多线程、并发、同步等
#####线程池
背景介绍：
合理利用线程池能够带来三个好处。第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。
线程池参数介绍：
>corePoolSize(线程池基本大小)：线程池中活跃线程数量，需要说明的是，线程池创建的时候，线程并不会被创建(除非调用prestartCoreThread方法来初始化线程)，而是在有任务进来的时候进行创建。
>
>runnableTaskQueue(任务队列)：当线程池中执行任务的线程数量已经达到corePoolSize时，新进来的任务会被放入阻塞队列
>
>maximumPoolSize(线程池最大大小)：当阻塞队列已经满了的时候，还有任务进来，就会再创建线程，直到最大线程数量达到maximumPoolSize大小。
>
>ThreadFactory(定义线程名称)：
>RejectedExecutionHandler(饱和策略)：当池中线程的数量达到maximumPoolSize值，并且阻塞队列也满了，那么就会根据饱和策略来处理后续的任务。比如是阻塞、丢弃、抛异常、等，具体有4种饱和策略。
>
>keepAliveTime(线程活动保持时间):当线程执行完任务之后，一直空闲超过指定时间时，就会将线程回收，直到池中线程的数量达到corePoolSize大小。
>
>TimeUnit(线程活动的时间单位):

一般使用Executors类来创建线程池，而不是自己去new ThreadPoolExecutor();

常用newCachedThreadPool(缓存，超过60s回收)和newFixedThreadPool(固定容量)


#####同步、锁机制
notify:
wait:
interrupt:
线程状态：
join:
yield:

生产者/消费者队列：
ThreadLocal:
>ThreadLocal用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择ThreadLocal变量。

为什么notify()/wait()：等方法在Object中？
>因为每个对象中锁成为一个监视器。这样，每个类都有用于线程通信的基本方法。

为什么notify()/wait()：等方法必须在同步块中 ？
>一个线程需要调用对象的wait()方法的时候，这个线程必须拥有该对象的锁，所以必须在同步块内部才会持有对象的锁。

同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。

静态同步方法的锁是这个类对象，所有这个类的实例的同步方法都会被阻塞，竞争锁。


#####IO、SOCKET、BUFFER

#####类加载
1.什么时候类会被加载？--虚拟机规范没有指定，跟不同的JVM虚拟机实现有关。
一般情况下：
>第一：生成该类对象的时候，会加载该类及该类的所有父类；
第二：访问该类的静态成员的时候；
第三：class．forName("类名")；

类加载后，被放在JVM的方法区。

2.加载的类什么时候会被初始化？
>1）使用new关键字实例化对象
>
>2）读取一个类的静态字段（被final修饰、已在编译期把结果放在常量池的静态字段除外）
>
>3）设置一个类的静态字段（被final修饰、已在编译期把结果放在常量池的静态字段除外）
>
>4）调用一个类的静态方法

3.类不会被初始化的场景
>被final修饰静态字段在操作使用时，不会使类进行初始化，因为在编译期已经将此常量放在常量池。
>
> 由 static 关键字修饰的（如：类变量[静态变量]、静态代码块）将在类被初始化创建实例对象之前被初始化，而且是按顺序从上到下依次被执行；

3.加载顺序
> bootstrapClassLoader/ExtendsClassLoader/appclassLoader/usercustomClassLoader
>
>Bootstrap：会加载<Java_Runtime_Home>/lib 下所有的jar到内存。
>ExtendsClassLoader：加载java.ext.dir 指定位置中的类库加载到内存中
>AppClassLoader(systemclassloader):将系统类路径（CLASSPATH）中的类加载到内存。
>user自定义的类加载，会根据findclass的实现加载相应类到内存。

#####JVM内存分区、内存优化、常见参数
JVM内存中各区域解释

[http://www.open-open.com/lib/view/open1348919888275.html](http://www.open-open.com/lib/view/open1348919888275.html "JAVA内存模型")

方法区：
>也称"永久代” 、“非堆.它用于存储虚拟机加载的类信息、常量、静态变量、是各个线程共享的内存区域。默认最小值为16MB，最大值为64MB，可以通过-XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小。

>运行时常量池：是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。

虚拟机栈:
>描述的是java 方法执行的内存模型：每个方法被执行的时候 都会创建一个“栈帧”用于存储局部变量表(包括参数)、操作栈、方法出口等信息。每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。声明周期与线程相同，是线程私有的。

>局部变量表:所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量是完全确定的，在运行期间栈帧不会改变局部 变量表的大小空间。

本地方法栈：
虚拟机栈为虚拟机执行的java方法服务，而本地方法栈则是为Native方法服务。

堆 ：
>也叫做java 堆、GC堆是java虚拟机所管理的内存中最大的一块内存区域，也是被各个线程共享的内存区域，在JVM启动时创建。该内存区域存放了对象实例及数组(所有new的对象)。
>其大小通过-Xms(最小值)和-Xmx(最大值)参数设置。
>
>现在收集器都是采用分代收集算法，堆被划分为新生代和老年代。新生代主要存储新创建的对象和尚未进入老年代的对象。老年代存储经过多次新生代GC(Minor GC)任然存活的对象。
>
>新生代：
>> 程序新创建的对象都是从新生代分配内存，新生代由Eden Space和两块相同大小的Survivor Space(通常又称S0和S1或From和To)构成，可通过-Xmn参数来指定新生代的大小，也可以通过-XX:SurvivorRation来调整Eden Space及Survivor Space的大小。
>
>老年代：
>>用于存放经过多次新生代GC任然存活的对象，例如缓存对象，新建的对象也有 可能直接进入老年代，主要有两种情况：①.大对象，可通过启动参数设置-XX:PretenureSizeThreshold=1024(单位为字节，默 认为0)来代表超过多大时就不在新生代分配，而是直接在老年代分配。②.大的数组对象，切数组中无引用外部对象。

老年代所占的内存大小为-Xmx对应的值减去-Xmn对应的值。

程序计数器 :
>它的作用是当前线程所执行的字节码的行号指示器，在虚拟机的模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。

直接内存：
>直接内存并不是虚拟机内存的一部分，也不是Java虚拟机规范中定义的内存区域。jdk1.4中新加入的NIO，引入了通道与缓冲区的IO方式，它可以调用Native方法直接分配堆外内存，这个堆外内存就是本机内存，不会影响到堆内存的大小。
>>这里就是BUffer.allocateheap啥获得的直接缓冲区。

##数据库
####基础

#####事务特性：
原子性
>指事务包含的所有操作要么全部成功，要么全部失败回滚

一致性
>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态

隔离性
>当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离

持久性
>指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作

在MySQL数据库中查看当前事务的隔离级别：

    select @@tx_isolation;

在MySQL数据库中设置事务的隔离 级别：

    set  [glogal | session]  transaction isolation level 隔离级别名称;
	或者
    set tx_isolation=’隔离级别名称;’

#####索引
数据库索引是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。
>B树降低了树的深度，因此降低了深层的IO消耗。

为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)，但是一般用户更关心的是查询的时间，因此需要创建索引。

使用索引的优点：
>通过唯一索引，保证数据的唯一性。
>加快检索速度。
>加快表与表之间的连接加快分组和排序的时间。

缺点
>增、删、改时由于要维护索引，因此增删改的效率会比没有索引低。

在什么时候、什么地方创建索引？
>在经常需要搜索的列上，可以加快搜索的速度；在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。
>>不建议建索引的的地方：当修改性能远远大于检索性能时，不应该创建索引。只有很少数据，或者很少查询的不要建索引。

唯一索引/主键索引、

多列索引(复合索引)：
>在复合索引中，记录首先按照第一个字段排序。对于在第一个字段上取值相同的记录，系统再按照第二个字段的取值排序，以此类推。因此只有复合索引的第一个字段出现在查询条件中，该索引才可能被使用,因此将应用频度高的字段，放置在复合索引的前面，会使系统最大可能地使用此索引，发挥索引的作用。
>>匹配sql语句中条件语句左边的部分。

创建索引
    
	alter table table_name ADD INDEX index_name(column_name);//即在table上的某列增加名称为index_name的索引。
	
	alter table table_name ADD INDEX index_name2(column1,column2,column3);

	CREATE INDEX index_name on table_name(column1,column2);//这个适用单列和多列索引.
唯一索引创建：
	
	创建索引，例如CREATE UNIQUE INDEX <索引的名字> ON tablename (列的列表);
	修改表，例如ALTER TABLE tablename ADD UNIQUE [索引的名字] (列的列表);
	创建表的时候指定索引，例如CREATE TABLE tablename ( [...], UNIQUE [索引的名字] (列的列表) 
	);

#####主键、外键
主键
> 主键是数据表的唯一索引，比如学生表里有学号和姓名，姓名可能有重名的，但学号确是唯一的，你要从学生表中搜索一条纪录如查找一个人，就只能根据学号去查找，这才能找出唯一的一个，这就是主键;如：id int(10) not null primary key auto_increment ；自增长的类型 ；
> >例如：
> 
>>学生表(学号，姓名，性别，班级)   　　学号是一个主键

>>课程表(课程号，课程名，学分)　　　　课程号是一个主键

>>成绩表(学号，课程号，成绩)　　　　　学号和课程号的属性组构成一个主键

对于成绩表来说，如果公共关键字在一个关系中是主关键字，那么这个公共关键字被称为另一个关系的外键。以一个关系的外键作主关键字的表被称为主表，具有此外键的表被称为主表的从表

主键是一种唯一性索引，但它必须指定为“PRIMARY KEY”
	
	ALTER TABLE tablename ADD PRIMARY KEY (列的列表); 
	CREATE TABLE tablename ( [...], PRIMARY KEY (列的列表) ); 
	ALTER TABLE table_name ADD CONSTRAINT pk_name PRIMARY KEY(列名); 

使用组合主键 

如果一列不能唯一区分一个表里的记录时，可以考虑多个列组合起来达到区分表记录的唯一性，形式 

	①创建时：create table sc ( 
	studentno int, 
	courseid int, 
	score int, 
	primary key (studentno,courseid) ); 

	②修改时：
	alter table tb_name add primary key (字段1,字段2,字段3);

外键：

	ALTER TABLE news_info[子表名] ADD CONSTRAINT FK_news_info_news_type[约束名] FOREIGN KEY (info_id)[子表列] REFERENCES news_type[主表名] (id)[主表列] ; 

#####左/右外连接
left join 或 left outer join
select * from ta left join tb on ta.id=tb.id
左边所有的值都加载，右边匹配到的查询，没有匹配到的填空值。

#####内连接
select * from ta join tb on ta.id=tb.id
就是全匹配、a/b表中都有的id才匹配
#####调优
查看执行计划

sql语句优化
>尽量避免在 where 子句中对字段进行 null 值判断,这个会做全表扫描，采取添加默认值的方式。
>尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。

数据库结构优化
>消除冗余(节省磁盘空间)、适当冗余(减少join)
>
>拆分表
>分库分表的设计、

垂直拆分
>垂直拆分就是要把表按模块划分到不同数据库表中（当然原则还是不破坏第三范式），这种拆分在大型网站的演变过程中是很常见的。当一个网站还在很小的时候，只有小量的人来开发和维护，各模块和表都在一起，当网站不断丰富和壮大的时候，也会变成多个子系统来支撑，这时就有按模块和功能把表划分出来的需求。其实，相对于垂直切分更进一步的是服务化改造，说得简单就是要把原来强耦合的系统拆分成多个弱耦合的服务，通过服务间的调用来满足业务需求看，因此表拆出来后要通过服务的形式暴露出去，而不是直接调用不同模块的表，淘宝在架构不断演变过程，最重要的一环就是服务化改造，把用户、交易、店铺、宝贝这些核心的概念抽取成独立的服务，也非常有利于进行局部的优化和治理，保障核心模块的稳定性
>>垂直拆分：单表大数据量依然存在性能瓶颈

水平拆分
>上面谈到垂直切分只是把表按模块划分到不同数据库，但没有解决单表大数据量的问题，而水平切分就是要把一个表按照某种规则把数据划分到不同表或数据库里。例如像计费系统，通过按时间来划分表就比较合适，因为系统都是处理某一时间段的数据。而像SaaS应用，通过按用户维度来划分数据比较合适，因为用户与用户之间的隔离的，一般不存在处理多个用户数据的情况，简单的按user_id范围来水平切分
>>通俗理解：水平拆分行，行数据拆分到不同表中， 垂直拆分列，表数据拆分到不同表中

#####数据库范式
简而言之，第一范式就是无重复的列。





##框架
#####Spring
#####IOC/AOP


##设计模式
#####单例、工厂、代理、包装器、建造者、观察者（listener）
#####开闭原则、里氏代换、依赖倒置（面向接口）、
###Linux脚本、容器配置等